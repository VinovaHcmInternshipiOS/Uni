//
//  NotificationViewController.swift
//  Uni
//
//  Created nguyen gia huy on 25/12/2020.
//  Copyright Â© 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Edward
//

import UIKit
import SkeletonView

class NotificationViewController: BaseViewController {

    @IBOutlet weak var lbNoData: UILabel!
    @IBOutlet weak var heightTableView: NSLayoutConstraint!
    @IBOutlet weak var lbNotification: UILabel!
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var scrollView: UIScrollView!
    private var pullControl = UIRefreshControl()
    var listNotification = [NotificationUser?]()
    var presenter: NotificationPresenterProtocol

	init(presenter: NotificationPresenterProtocol) {
        self.presenter = presenter
        super.init(nibName: "NotificationViewController", bundle: nil)
    }

    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

	override func viewDidLoad() {
        super.viewDidLoad()
        presenter.view = self
        setupLanguage()
        setupUI()
        presenter.fetchNotification()
    }

    
    func setupUI(){
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(UINib(nibName: "NotificationCell", bundle: nil), forCellReuseIdentifier: "NotificationCell")
        addBackToNavigation()
        scrollView.alwaysBounceVertical = true
        pullRefreshData()
        pullControl.tintColor = AppColor.YellowFAB32A
        skeletonView()
        
    }
    
    func skeletonView(){
        
        tableView.isSkeletonable = true
        tableView.showAnimatedSkeleton(usingColor: UIColor.clouds, animation: nil, transition:.crossDissolve(0.25))
    }
    
    func setupLanguage() {
        lbNotification.text = AppLanguage.Notifications.localized
        lbNoData.text = AppLanguage.HandleError.noData.localized
    }
    
    @objc func pulledRefreshControl(sender:AnyObject) {
        showSpinner()
        listNotification.removeAll()
        refreshListNotification()
        
    }
    
    func refreshListNotification() {
        skeletonView()
        presenter.fetchNotification()
        
    }
    
    private func pullRefreshData() {
        pullControl.addTarget(self, action: #selector(pulledRefreshControl), for: UIControl.Event.valueChanged)
        scrollView.addSubview(pullControl)

    }
    
    func remakeData(){
        listNotification = presenter.infoNotification
        tableView.insertRows(at: [IndexPath(row: 0, section: 0)], with: .automatic)
        tableView.performBatchUpdates {
            tableView.reloadRows(at: [IndexPath(row: 0, section: 0)], with: .automatic)
        } completion: { [self] (Bool) in
            hideSkeletonView()
            removeSpinner()
        }
        checkEmptyData()
    }
    
    func hideSkeletonView(){
        pullControl.endRefreshing()
        tableView.hideSkeleton()
    }
    
    func checkEmptyData(){
        if presenter.infoNotification.count != 0 {
            lbNoData.isHidden = true
        } else {
            lbNoData.isHidden = false
        }
    }

}

extension NotificationViewController: SkeletonTableViewDataSource {
    func collectionSkeletonView(_ skeletonView: UITableView, cellIdentifierForRowAt indexPath: IndexPath) -> ReusableCellIdentifier {
        return "NotificationCell"
        
    }
    func collectionSkeletonView(_ skeletonView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return listNotification.count
    }
    
    func numSections(in collectionSkeletonView: UITableView) -> Int {
        return 1
    }
}

extension NotificationViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if let listNotification = listNotification[indexPath.row] {
            listNotification.state = true
            tableView.reloadRows(at: [IndexPath(row: indexPath.row, section: 0)], with: .automatic)
            hideSkeletonView()
            presenter.seenNotification(keyNotification: listNotification.keyNotification ?? "", date: "\(getCurrentDate()) \(getCurrentTime())")
            let contentNotification = ContentNotificationViewController(presenter: ContentNotificationPresenter())
            contentNotification.titleNoti = "\(listNotification.title ?? "")"
            contentNotification.contentNoti = "\(listNotification.content ?? "")"
            contentNotification.modalPresentationStyle = .overCurrentContext
            present(contentNotification, animated: false, completion: nil)
            
        } else {return}
       

        
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 100
    }
    
    func tableView(_ tableView: UITableView, willDisplay cell: UITableViewCell, forRowAt indexPath: IndexPath) {
        self.tableView.layoutIfNeeded()
        self.heightTableView.constant = self.tableView.contentSize.height
    }
    
//    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
//        let closeAction = UIContextualAction(style: .normal, title:  "Close", handler: { (ac:UIContextualAction, view:UIView, success:(Bool) -> Void) in
//                 print("OK, marked as Closed")
//                 success(true)
//             })
//        
//        closeAction.image = AppIcon.icBellRed
//             closeAction.backgroundColor = . white
//
//             return UISwipeActionsConfiguration(actions: [closeAction])
//    }
    
}

extension NotificationViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return listNotification.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        if let cell = tableView.dequeueReusableCell(withIdentifier: "NotificationCell", for: indexPath) as? NotificationCell {
            let calendar = Calendar.current
            let componentsTime = calendar.dateComponents([.day,.month,.year,.hour,.minute,.second], from: is12hClockFormat() == true ? (formatterDateTime12h(time: listNotification[indexPath.row]?.date ?? "").toDateTimeFormat(format: "dd-MM-yyyy hh:mma")) : (formatterDateTime24h(time: listNotification[indexPath.row]?.date ?? "").toDateTimeFormat(format: "dd-MM-yyyy HH:mm")) , to: is12hClockFormat() == true ? (formatterDateTime12h(time: getCurrentDateTime12h()).toDateTimeFormat(format: "dd-MM-yyyy hh:mma")) : (formatterDateTime24h(time: getCurrentDateTime12h()).toDateTimeFormat(format: "dd-MM-yyyy HH:mm")))
            cell.lbTitle.text = "\(listNotification[indexPath.row]?.title ?? "")"
            cell.lbDate.text = "\(componentsTime.day == 0 ? (componentsTime.hour == 0 ? (componentsTime.minute == 0 ? AppLanguage.JustNow.localized : "\(componentsTime.minute ?? 0)m ago") : "\(componentsTime.hour ?? 0)h ago") : "\(componentsTime.day ?? 0)d ago")"
            cell.viewState.backgroundColor = listNotification[indexPath.row]?.state == true ? AppColor.SilverE5E5E5 : AppColor.YellowFAB32A
            return cell
        } else { return UITableViewCell()}
    }
    
    
}


extension NotificationViewController: NotificationViewProtocol {
    func fetchNotificationSuccess() {
        remakeData()
    }
    
    func fetchNotificationFailed() {
        checkEmptyData()
        removeSpinner()
        pullControl.endRefreshing()
        
    }
    
    
}
