//
//  CreateEventPresenter.swift
//  Uni
//
//  Created nguyen gia huy on 19/11/2020.
//  Copyright Â© 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Edward
//

import Foundation
import FirebaseAuth
import FirebaseDatabase
import Firebase
import FirebaseStorage
import UIKit
import FirebaseMessaging
import UserNotifications

// MARK: View -
protocol CreateEventViewProtocol: class {
    func createEventSuccess(path:String,title:String)
    func createEventFailed()
    func uploadImageLandscapeSuccess(keyRef:String,pathEvent:String)
    func uploadImagePortalSuccess(keyRef:String,pathEvent:String)
    func uploadImageLandscapeFailed()
    func uploadImagePortalFailed()
    func updateImageEventSuccess()
    func updateImageEventFailed()
}

// MARK: Presenter -
protocol CreateEventPresenterProtocol: class {
    var view: CreateEventViewProtocol? { get set }
    var detailEvent: ADEEvent? { get set}
    func createEvent(urlImgLanscape: String,urlImgPortal:String,title:String,overview:String,location:String,date:String,checkin:String,checkout:String,score:Int)
    func uploadImage(images: [UIImage],path:String)
    func updateImageEvent(keyRef:String,path:String,type:typeImage)
    func sendPushNotification(to token: String, title: String, body: String)
}

class CreateEventPresenter: CreateEventPresenterProtocol {

    weak var view: CreateEventViewProtocol?
    var ref = Database.database().reference()
    var databaseHandle = DatabaseHandle()
    var user = Auth.auth().currentUser
    let storageRef = Storage.storage().reference()
    var detailEvent: ADEEvent?
    func sendPushNotification(to token: String, title: String, body: String) {
        let urlString = "https://fcm.googleapis.com/fcm/send"
        let url = NSURL(string: urlString)!
        let paramString: [String : Any] = ["condition": "'notify' in topics",
                                           "priority" : "high",
                                           "notification" : [
                                             "body" : body,
                                             "title" : title,
                                             "sound" : "default"
                                           ]
        ]
        let request = NSMutableURLRequest(url: url as URL)
        request.httpMethod = "POST"
        request.httpBody = try? JSONSerialization.data(withJSONObject:paramString, options: [.prettyPrinted])
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.setValue(AppKey.keyPushNotification, forHTTPHeaderField: "Authorization")
        let task =  URLSession.shared.dataTask(with: request as URLRequest)  {  (data, response, error) in
            do {
                if let jsonData = data {
                    if let jsonDataDict  = try JSONSerialization.jsonObject(with: jsonData, options: JSONSerialization.ReadingOptions.allowFragments) as? [String: AnyObject] {
                        
                        NSLog("Received data:\n\(jsonDataDict))")
                    }
                }
            } catch let err as NSError {
                
                print(err.debugDescription)
            }
        }
        task.resume()
    }
    
    
    func createEvent(urlImgLanscape: String, urlImgPortal: String, title: String, overview: String, location: String, date: String, checkin: String, checkout: String, score: Int) {
        let path = self.ref.child("Event").childByAutoId()
        let childAuto = path.key
        let sentValue = ["ImageLandscape":"\(urlImgLanscape)","ImagePortal":"\(urlImgPortal)","Title":"\(title)","Overview":"\(overview)","Location":"\(location)","Date":"\(date)","Checkin":"\(checkin)","Checkout":"\(checkout)","Score":score,"Key":"\(childAuto!)","Type":"ComingSoon"] as [String : Any]
        path.setValue(sentValue) { [self]
            (error:Error?, ref:DatabaseReference) in
            if error != nil {
                view?.createEventFailed()
            }
            else
            {
                view?.createEventSuccess(path: childAuto!,title: title)
            }
        }
    }
    
    func uploadImage(images:[UIImage],path:String) {
        for i in 0..<images.count {
            let storedImage = storageRef.child("Event/\(path)/\(images[i].hashValue)")
            if let uploadData = images[i].jpegData(compressionQuality: 1)
            {
                let metaData = StorageMetadata()
                metaData.contentType = "image/jpg"
                storedImage.putData(uploadData, metadata: metaData, completion: { [self]  (metadata, error) in
                    if error != nil {
                        switch i {
                        case 0:
                            view?.uploadImageLandscapeFailed()
                        case 1:
                            view?.uploadImagePortalFailed()
                        default:
                            break
                        }
                    }
                    else {
                        storedImage.downloadURL { (url, error) in
                            if error == nil {
                                if let url = url {
                                    switch i {
                                    case 0:
                                        view?.uploadImageLandscapeSuccess(keyRef: "\(url)", pathEvent: path)
                                
                                    case 1:
                                        view?.uploadImagePortalSuccess(keyRef: "\(url)", pathEvent: path)
                                     
                                    default:
                                        break
                                    }
                                } else {return}
 
                            }
                        }

                    }
                })
                
            }
        }
        
    }
    
    func updateImageEvent(keyRef: String, path: String,type:typeImage) {
        let ImageEvent = ["Event/\(path)/Image\(type)":(keyRef)] as [String : Any]
        ref.updateChildValues(ImageEvent as [AnyHashable : Any]) { [self] (error, snapshot) in
            if error != nil {
                view?.updateImageEventFailed()
            } else {
                view?.updateImageEventSuccess()
            }
        }
    }
    
}
