//
//  CalendarEventViewController.swift
//  Uni
//
//  Created nguyen gia huy on 15/01/2021.
//  Copyright Â© 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Edward
//

import UIKit
import FSCalendar
import SkeletonView
class CalendarEventViewController: BaseViewController  {
    
    @IBOutlet weak var ActivityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var lbNoData: UILabel!
    @IBOutlet weak var heightCollectionView: NSLayoutConstraint!
    @IBOutlet weak var collectionView: UICollectionView!
    @IBOutlet weak var lbEnded: UILabel!
    @IBOutlet weak var lbComingSoon: UILabel!
    @IBOutlet weak var lbHappening: UILabel!
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var lbCalendarEvents: UILabel!
    @IBOutlet weak var Calendar: FSCalendar!
    private var pullControl = UIRefreshControl()
    var presenter: CalendarEventPresenterProtocol
    init(presenter: CalendarEventPresenterProtocol) {
        self.presenter = presenter
        super.init(nibName: "CalendarEventViewController", bundle: nil)
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        presenter.view = self
        presenter.getInfoEvent()
        showSpinner()
        setupUI()
        setupLanguage()
        heightCollectionView.constant = 0
    }
    
    func setupUI(){
        addMenuButton()
        Calendar.appearance.caseOptions = FSCalendarCaseOptions.headerUsesCapitalized
        Calendar.appearance.titleFont = AppFont.Raleway_Medium_17
        Calendar.appearance.headerTitleFont = AppFont.Raleway_Medium_18
        Calendar.appearance.weekdayFont = AppFont.Raleway_Medium_16
        Calendar.appearance.weekdayTextColor = AppColor.YellowFAB32A
        Calendar.appearance.headerTitleColor = AppColor.YellowFAB32A
        pullRefreshData()
        pullControl.tintColor = AppColor.YellowFAB32A
        skeletonCollectionView()
        ActivityIndicator.isHidden = true
        scrollView.alwaysBounceVertical = true
        if AppLanguage.English.localized == "English" {
            Calendar.locale = Locale(identifier: "en_US")
        } else {
            Calendar.locale = Locale(identifier: "vi_VN")
        }
        collectionView.delegate = self
        collectionView.dataSource = self
        collectionView.register(UINib(nibName: "ComingSoonEndedCellAppHome", bundle: nil), forCellWithReuseIdentifier: "ComingSoonEndedCellAppHome")
    }
    
    func setupLanguage(){
        lbCalendarEvents.text = AppLanguage.Calendar.CalendarEvent.localized
        lbHappening.text = AppLanguage.Calendar.EventHappening.localized
        lbComingSoon.text = AppLanguage.Calendar.EventComingSoon.localized
        lbEnded.text = AppLanguage.Calendar.EventEnded.localized
        lbNoData.text = AppLanguage.HandleError.noData.localized
    }
    
    private func pullRefreshData() {
        pullControl.addTarget(self, action: #selector(pulledRefreshControl), for: UIControl.Event.valueChanged)
        scrollView.addSubview(pullControl)
        
    }
    
    @objc func pulledRefreshControl(sender:AnyObject) {
        presenter.getInfoEvent()
        Calendar.layoutIfNeeded()
    }
    
    func skeletonCollectionView(){
        collectionView.isSkeletonable = true
        collectionView.showAnimatedSkeleton(usingColor: UIColor.clouds, animation: nil, transition:.crossDissolve(0.25))
    }
    
    func checkEmptyData(){
        if presenter.eventInDay.count == 0 {
            lbNoData.isHidden = false
        } else {
            lbNoData.isHidden = true
        }
        ActivityIndicator.stopAnimating()
        ActivityIndicator.isHidden = true
    }
    
    
}
extension CalendarEventViewController: FSCalendarDelegate,FSCalendarDelegateAppearance {
    func calendar(_ calendar: FSCalendar, appearance: FSCalendarAppearance, eventDefaultColorsFor date: Date) -> [UIColor]? {
        let result = formatDateToString(date: date)
        if result.formatStringToDate() < getCurrentDate().formatStringToDate(){
            return [.systemRed]
        } else if result.formatStringToDate() > getCurrentDate().formatStringToDate() {
            return [.systemYellow]
        } else {
            return [.systemGreen]
        }
    }
}

extension CalendarEventViewController: FSCalendarDataSource {
    
    func calendar(_ calendar: FSCalendar, numberOfEventsFor date: Date) -> Int {
        if presenter.listEvent.contains(where: {$0?.date == formatDateToString(date: date)}) {
            return 1
        } else {
            return 0
        }
        
    }
    func calendar(_ calendar: FSCalendar, didSelect date: Date, at monthPosition: FSCalendarMonthPosition) {
        lbNoData.isHidden = true
        heightCollectionView.constant = 300
        collectionView.layoutIfNeeded()
        presenter.fetchEvent(date: formatDateToString(date: date))
        ActivityIndicator.isHidden = false
        ActivityIndicator.startAnimating()
        collectionView.reloadData()
        
    }
    
}

extension CalendarEventViewController: CalendarEventViewProtocol {
    func fetchEventInDaySuccess() {
        collectionView.hideSkeleton()
        collectionView.insertItems(at: [IndexPath(row: presenter.eventInDay.count - 1, section: 0)])
        collectionView.performBatchUpdates({
            collectionView.reloadItems(at: [IndexPath(row: presenter.eventInDay.count - 1, section: 0)])
        }){_ in
            // optional closure
            print("finished updating cell")
        }
        checkEmptyData()
        
    }
    
    func fetchEventInDayFailed() {
        collectionView.hideSkeleton()
        checkEmptyData()
    }
    
    func likeEventSuccess() {
        
    }
    
    func likeEventFailed() {
        
    }
    
    func fetchEventSuccess() {
        Calendar.reloadData()
        pullControl.endRefreshing()
        removeSpinner()
    }
    
    func fetchEventFailed() {
        pullControl.endRefreshing()
        removeSpinner()
    }
    
    
}

extension CalendarEventViewController: SkeletonCollectionViewDataSource {
    func collectionSkeletonView(_ skeletonView: UICollectionView, cellIdentifierForItemAt indexPath: IndexPath) -> ReusableCellIdentifier {
        return "ComingSoonEndedCellAppHome"
    }
    func collectionSkeletonView(_ skeletonView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return 2
    }

    func numSections(in collectionSkeletonView: UICollectionView) -> Int {
        return 1
    }
    
}

extension CalendarEventViewController: UICollectionViewDelegate,UICollectionViewDataSource,UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize(width: 183 , height: 300)
        
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return presenter.eventInDay.count
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        let detailEvent = DetailEventViewController(presenter: DetailEventPresenter())
        detailEvent.keyDetailEvent = (presenter.eventInDay[indexPath.row]?.key)!
        detailEvent.stateLike = (presenter.eventInDay[indexPath.row]?.stateLike)!
            detailEvent.updateStateLike = { [self] state in
                presenter.eventInDay[indexPath.row]?.stateLike = state
                collectionView.reloadItems(at: [IndexPath(row: indexPath.row, section: 0)])
            }
        navigationController?.pushViewController(detailEvent, animated: true)
        
    }

    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "ComingSoonEndedCellAppHome", for: indexPath) as? ComingSoonEndedCellAppHome,let listEvent = presenter.eventInDay[indexPath.row]{
                cell.timeEvent.text = "\(getFormattedDate(date: listEvent.date ?? ""))\n\((listEvent.checkin ?? "").toTimeFormat(format: checkFormatTime12h()))-\((listEvent.checkout ?? "").toTimeFormat(format: checkFormatTime12h()))"
                cell.titleEvent.text = listEvent.title
            listEvent.stateLike == true ? cell.btLike.setImage(AppIcon.icLove, for: .normal) : cell.btLike.setImage(AppIcon.icUnLove, for: .normal)
                cell.like = { [self] in
                    switch listEvent.stateLike {
                    case true:
                        cell.btLike.setImage(AppIcon.icUnLove, for: .normal)
                        listEvent.stateLike = false
                        presenter.isLikeEvent(keyEvent: listEvent.key ?? "", stateLike: false)
                    default:
                        cell.btLike.setImage(AppIcon.icLove, for: .normal)
                        listEvent.stateLike = true
                        presenter.isLikeEvent(keyEvent: listEvent.key ?? "", stateLike: true)
                    }
                }

                if let imageURL = listEvent.urlImage {
                    cell.imageView.sd_setImage(with: URL(string: imageURL), completed: nil)
                }
                return cell
            } else {return UICollectionViewCell()}

    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 0.00000000000000001
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return 0.00000000000000001
        
    }
    
    
}

